#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;

#define INT_MAX 9999

/**
 * 좌표 클래스
 */
class Point
{
public:
	/**
	 * 행
	 */
	size_t row;

	/**
	 * 열
	 */
	size_t col;

public:
	/**
	 * Construct from 좌표.
	 */
	Point(size_t row, size_t col)
	{
		this->row = row;
		this->col = col;
	};

	/**
	 * 두 좌표가 같은 지 비교
	 */
	auto operator==(const Point &obj) const -> bool
	{
		return row == obj.row && col == obj.col;
	};
};

/**
 * 행렬, 배열의 배열.
 *
 * @tparam T 원소 타입
 */
template <typename T>
using Matrix = vector<vector<T>>;

/**
 * 등산로 및 등산로의 각 지점 간 이동에 소요되는 힘을 담은 행렬 클래스
 *
 * 이동 간에 소요되는 힘을 곗ㄴ하는 함수 또한 가지고 있다.
 */
class Mountain
	: public Matrix<int>
{
private:
	typedef Matrix<int> super;

public:
	/* -----------------------------------------------------
		CONSTRUCTORS
	----------------------------------------------------- */
	/**
	 * Construct from 정방행렬의 크기.
	 */
	Mountain(size_t size)
		: super(size, vector<int>(size, -1))
	{
		// 데이터 입력
		for (size_t r = 0; r < size; r++)
			for (size_t c = 0; c < size; c++)
				cin >> at(r).at(c);
	};

	/* -----------------------------------------------------
		ACCESSORS
	----------------------------------------------------- */
	using super::at;
	
	auto at(const Point &p) const -> const int&
	{
		return at(p.row).at(p.col);
	};

	/* -----------------------------------------------------
		FINDERS
	----------------------------------------------------- */
	/**
	 * 목표 지점으로 가는 데 있어 가장 적게 소요되는 힘을 구함
	 *
	 * @param end 목표지점
	 * @return 최소 소요 힘
	 */
	auto calcPower(const Point &end) const -> int
	{
		int hours = INT_MAX;

		// 가장 자리를 순회해야 한다.
		size_t r, c;
		
		// 상단 좌측에서부터 우측으로
		r = 0;
		for (c = 0; c < this->size(); c++)
			hours = min(hours, calcPower(Point(r, c), end));

		// 우측 상단으로부터 하단까지
		c = this->size() - 1;
		for (r = 0; r < this->size(); r++)
			hours = min(hours, calcPower(Point(r, c), end));

		// 하단 우측으로부터 좌측까지
		r = this->size() - 1;
		for (c = 0; c < this->size(); c++)
			hours = min(hours, calcPower(Point(r, c), end));

		// 좌측 하단으로부터 상단으로
		c = 0;
		for (r = 0; r < this->size(); r++)
			hours = min(hours, calcPower(Point(r, c), end));

		return hours;
	};

private:
	/**
	 * 각 시작 지점별로 목표 지점으로 가는 데 있어 가장 적게 소요되는 힘을 구함
	 *
	 * @param start 시작지점
	 * @param end 목표지점
	 *
	 * @return 최소 소요 힘
	 */
	auto calcPower(const Point &start, const Point &end) const -> int
	{
		Point outside(-1, -1);
		Matrix<int> visited(this->size(), vector<int>(this->size(), INT_MAX));

		return calcPower(outside, start, end, visited, 0);
	};

	/**
	 * 각 지점간 이동시에 소요되는 힘을 계산
	 *
	 * @param prev 이전 지점
	 * @param now 현재 지점
	 * @param endP 목표 지점
	 * @param visited 각 지점에 방문했을 때 소요된 최소 시간을 담은 행렬
	 * @param step 현재까지 소모한 시간
	 *
	 * @return 최소 소요 힘
	 */
	auto calcPower
		(
			const Point &prev, const Point &now, const Point &end,
			Matrix<int> &visited, int step
		) const -> int
	{
		// -------------------------------------------
		//	전처리
		// -------------------------------------------
		if (now.row >= this->size() || now.col >= this->size())
		{
			// 범위를 벗어남
			return INT_MAX;
		}

		// 현재까지 소모한 힘을 계산
		if (prev == Point(-1, -1))
		{
			// 첫 출발
			// 첫 지점의 값을 제곱한만큼 힘을 소모한다
			step = (int)pow(this->at(now), 2);
		}
		else if (this->at(now) > this->at(prev))
		{
			// 오르막길을 오를 때는
			// 높이 차의 제곱만큼 힘이 소요되며
			step += (int)pow(this->at(now) - this->at(prev), 2);
		}
		else if (this->at(now) < this->at(prev))
		{
			// 내리막길을 걸을 때는
			// 높이 차 만큼의 힘만 소요함
			step += this->at(prev) - this->at(now);
		} // 평지를 걸을 때는 힘의 소모가 없다

		// -------------------------------------------
		//	재귀탐색 종료
		// -------------------------------------------
		if (now == end)
		{
			// 목표 지점에 도달함
			return step;
		}
		else if (visited[now.row][now.col] <= step)
		{
			// 현재 지점을, 더 적은 힘을 들여 방문할 수 있는 방법이 있다
			// 즉 좋지 못한 경로로 들어섬
			return INT_MAX;
		}

		// -------------------------------------------
		//	재귀 탐색
		// -------------------------------------------
		// 현재의 소요시간을 행렬에 기록
		visited[now.row][now.col] = step;
		
		int power = min
			({
				calcPower(now, Point(now.row - 1, now.col), end, visited, step), // 상
				calcPower(now, Point(now.row + 1, now.col), end, visited, step), // 하
				calcPower(now, Point(now.row, now.col - 1), end, visited, step), // 좌
				calcPower(now, Point(now.row, now.col + 1), end, visited, step)  // 우
			});

		return power;
	};
};

int main()
{
/*
5
3 3
1 2 4 3 2
1 3 5 4 4
2 3 6 5 1
3 1 4 1 3
2 3 3 5 3
*/
	size_t size, destRow, destCol;
	cin >> size >> destRow >> destCol;

	Mountain mountain(size);
	cout << mountain.calcPower(Point(destRow - 1, destCol - 1));

#ifdef _WIN32
	system("pause");
#endif
	return 0;
}